{"ast":null,"code":"'use strict';\n\nconst isOperator = require('./isOperator');\nmodule.exports = function castFilterPath(query, schematype, val) {\n  const ctx = query;\n  const any$conditionals = Object.keys(val).some(isOperator);\n  if (!any$conditionals) {\n    return schematype.castForQuery(null, val, ctx);\n  }\n  const ks = Object.keys(val);\n  let k = ks.length;\n  while (k--) {\n    const $cond = ks[k];\n    const nested = val[$cond];\n    if ($cond === '$not') {\n      if (nested && schematype && !schematype.caster) {\n        const _keys = Object.keys(nested);\n        if (_keys.length && isOperator(_keys[0])) {\n          for (const key of Object.keys(nested)) {\n            nested[key] = schematype.castForQuery(key, nested[key], ctx);\n          }\n        } else {\n          val[$cond] = schematype.castForQuery($cond, nested, ctx);\n        }\n        continue;\n      }\n    } else {\n      val[$cond] = schematype.castForQuery($cond, nested, ctx);\n    }\n  }\n  return val;\n};","map":{"version":3,"names":["isOperator","require","module","exports","castFilterPath","query","schematype","val","ctx","any$conditionals","Object","keys","some","castForQuery","ks","k","length","$cond","nested","caster","_keys","key"],"sources":["C:/Users/Lenovo/node_modules/mongoose/lib/helpers/query/castFilterPath.js"],"sourcesContent":["'use strict';\n\nconst isOperator = require('./isOperator');\n\nmodule.exports = function castFilterPath(query, schematype, val) {\n  const ctx = query;\n  const any$conditionals = Object.keys(val).some(isOperator);\n\n  if (!any$conditionals) {\n    return schematype.castForQuery(\n      null,\n      val,\n      ctx\n    );\n  }\n\n  const ks = Object.keys(val);\n\n  let k = ks.length;\n\n  while (k--) {\n    const $cond = ks[k];\n    const nested = val[$cond];\n\n    if ($cond === '$not') {\n      if (nested && schematype && !schematype.caster) {\n        const _keys = Object.keys(nested);\n        if (_keys.length && isOperator(_keys[0])) {\n          for (const key of Object.keys(nested)) {\n            nested[key] = schematype.castForQuery(\n              key,\n              nested[key],\n              ctx\n            );\n          }\n        } else {\n          val[$cond] = schematype.castForQuery(\n            $cond,\n            nested,\n            ctx\n          );\n        }\n        continue;\n      }\n    } else {\n      val[$cond] = schematype.castForQuery(\n        $cond,\n        nested,\n        ctx\n      );\n    }\n  }\n\n  return val;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,cAAc,CAAC;AAE1CC,MAAM,CAACC,OAAO,GAAG,SAASC,cAAcA,CAACC,KAAK,EAAEC,UAAU,EAAEC,GAAG,EAAE;EAC/D,MAAMC,GAAG,GAAGH,KAAK;EACjB,MAAMI,gBAAgB,GAAGC,MAAM,CAACC,IAAI,CAACJ,GAAG,CAAC,CAACK,IAAI,CAACZ,UAAU,CAAC;EAE1D,IAAI,CAACS,gBAAgB,EAAE;IACrB,OAAOH,UAAU,CAACO,YAAY,CAC5B,IAAI,EACJN,GAAG,EACHC,GACF,CAAC;EACH;EAEA,MAAMM,EAAE,GAAGJ,MAAM,CAACC,IAAI,CAACJ,GAAG,CAAC;EAE3B,IAAIQ,CAAC,GAAGD,EAAE,CAACE,MAAM;EAEjB,OAAOD,CAAC,EAAE,EAAE;IACV,MAAME,KAAK,GAAGH,EAAE,CAACC,CAAC,CAAC;IACnB,MAAMG,MAAM,GAAGX,GAAG,CAACU,KAAK,CAAC;IAEzB,IAAIA,KAAK,KAAK,MAAM,EAAE;MACpB,IAAIC,MAAM,IAAIZ,UAAU,IAAI,CAACA,UAAU,CAACa,MAAM,EAAE;QAC9C,MAAMC,KAAK,GAAGV,MAAM,CAACC,IAAI,CAACO,MAAM,CAAC;QACjC,IAAIE,KAAK,CAACJ,MAAM,IAAIhB,UAAU,CAACoB,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;UACxC,KAAK,MAAMC,GAAG,IAAIX,MAAM,CAACC,IAAI,CAACO,MAAM,CAAC,EAAE;YACrCA,MAAM,CAACG,GAAG,CAAC,GAAGf,UAAU,CAACO,YAAY,CACnCQ,GAAG,EACHH,MAAM,CAACG,GAAG,CAAC,EACXb,GACF,CAAC;UACH;QACF,CAAC,MAAM;UACLD,GAAG,CAACU,KAAK,CAAC,GAAGX,UAAU,CAACO,YAAY,CAClCI,KAAK,EACLC,MAAM,EACNV,GACF,CAAC;QACH;QACA;MACF;IACF,CAAC,MAAM;MACLD,GAAG,CAACU,KAAK,CAAC,GAAGX,UAAU,CAACO,YAAY,CAClCI,KAAK,EACLC,MAAM,EACNV,GACF,CAAC;IACH;EACF;EAEA,OAAOD,GAAG;AACZ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}